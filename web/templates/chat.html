{{ define "content" }}
<div x-data="chatApp()" class="flex flex-col h-full">
    <!-- Loading spinner for messages -->
    <div x-show="messagesLoading" class="flex-1 flex items-center justify-center bg-gray-50 dark:bg-dark-900">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-primary-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-3 text-gray-600 dark:text-gray-400">Loading messages...</p>
        </div>
    </div>

    <!-- Error message -->
    <div x-show="loadError" class="flex-1 flex items-center justify-center bg-gray-50 dark:bg-dark-900">
        <div class="text-center p-4 max-w-md">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-red-500 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <p class="mt-3 text-gray-800 dark:text-gray-200" x-text="loadError"></p>
            <button @click="loadMessages()" class="mt-4 px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg">
                Try Again
            </button>
        </div>
    </div>

    <!-- Messages container (only show when not loading and no errors) -->
    <div x-show="!messagesLoading && !loadError" class="flex-1 overflow-y-auto px-2 py-6 space-y-6 scrollbar-thin bg-gray-50 dark:bg-dark-900 transition-colors duration-200" id="chat-messages">
        <!-- Empty state for new chats -->
        <div x-show="messages.length === 0" class="flex flex-col items-center justify-center h-full text-center p-4">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-gray-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
            </svg>
            <p class="text-gray-600 dark:text-gray-400">Start a new conversation by sending a message below.</p>
        </div>

        <!-- Message list -->
        <template x-for="(message, index) in messages" :key="index">
            <div :class="message.role === 'user' ? 'flex justify-end' : 'flex justify-start'" class="mx-1 sm:mx-2">
                <div :class="message.role === 'user' ?
                    'bg-primary-500 text-white rounded-2xl rounded-tr-none py-3 px-4 max-w-[95%]' :
                    'bg-gray-200 dark:bg-[#1e293b] text-gray-800 dark:text-gray-100 rounded-2xl rounded-tl-none py-3 px-4 max-w-[95%] transition-colors duration-200'">
                    <div x-html="formatMessage(message.content)" class="message-content"></div>
                    <div class="text-xs mt-1 opacity-70 text-right" x-text="formatTime(message.timestamp)"></div>
                </div>
            </div>
        </template>

        <!-- Typing indicator -->
        <div x-show="isTyping" class="flex justify-start mx-1 sm:mx-2">
            <div class="bg-gray-200 dark:bg-[#1e293b] text-gray-800 dark:text-gray-100 rounded-2xl rounded-tl-none py-3 px-4 transition-colors duration-200">
                <div class="flex space-x-1">
                    <div class="w-2 h-2 rounded-full bg-gray-500 dark:bg-gray-400 animate-bounce"></div>
                    <div class="w-2 h-2 rounded-full bg-gray-500 dark:bg-gray-400 animate-bounce" style="animation-delay: 0.2s"></div>
                    <div class="w-2 h-2 rounded-full bg-gray-500 dark:bg-gray-400 animate-bounce" style="animation-delay: 0.4s"></div>
                </div>
            </div>
        </div>

        <div id="scroll-anchor"></div>
    </div>

    <!-- Message input form -->
    <div class="border-t border-gray-200 dark:border-gray-800 bg-white dark:bg-dark-800 p-4 transition-colors duration-200">
        <form @submit.prevent="sendMessage" class="flex space-x-2">
            <div class="flex-1 relative">
                <textarea
                        x-model="newMessage"
                        @keydown.enter.prevent="$event.shiftKey || sendMessage()"
                        class="w-full border border-gray-300 dark:border-gray-700 rounded-lg py-3 px-4 pr-12 focus:outline-none focus:ring-2 focus:ring-primary-500 dark:focus:ring-primary-400 bg-white dark:bg-[#1e293b] text-gray-800 dark:text-gray-100 resize-none transition-colors duration-200"
                        placeholder="Type a message..."
                        rows="1"
                        @input="autoGrow($event.target)"
                ></textarea>
                <div x-show="isLoading" class="absolute right-3 top-3.5">
                    <svg class="animate-spin h-5 w-5 text-primary-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            </div>
            <button
                    type="submit"
                    class="bg-primary-500 hover:bg-primary-600 text-white rounded-lg p-3 disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="!newMessage.trim() || isLoading"
            >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
                </svg>
            </button>
        </form>
    </div>
</div>
<script>
    function chatApp() {
        return {
            messages: [],
            newMessage: '',
            isLoading: false,
            isTyping: false,
            userId: 'user-' + Date.now(),
            ws: null,
            chatId: new URLSearchParams(window.location.search).get('id') || 'new',
            messagesLoading: true,
            loadError: null,
            reconnectAttempts: 0,

            init() {
                this.loadMessages();
                this.connectWebSocket();
            },

            loadMessages() {
                // Skip loading messages for new chats
                if (this.chatId === 'new') {
                    this.messages = [];
                    this.messagesLoading = false;
                    return;
                }

                this.messagesLoading = true;
                this.loadError = null;

                // Fetch chat history from API
                fetch(`/api/v1/chat/${this.chatId}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load messages: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.messages && Array.isArray(data.messages)) {
                            this.messages = data.messages.map(msg => ({
                                role: msg.role,
                                content: msg.content,
                                timestamp: new Date(msg.timestamp)
                            }));
                        } else {
                            this.messages = [];
                        }
                        this.messagesLoading = false;
                        // Scroll to bottom after messages are rendered
                        this.$nextTick(() => {
                            this.scrollToBottom();
                        });
                    })
                    .catch(error => {
                        console.error('Error loading messages:', error);
                        this.loadError = 'Failed to load chat history. Please try again.';
                        this.messagesLoading = false;
                    });
            },
            
            connectWebSocket() {
                if (this.ws && this.ws.readyState !== WebSocket.CLOSED) {
                    return; // Already connected or connecting
                }

                this.ws = new WebSocket(`ws://${window.location.host}/ws/${this.userId}`);

                this.ws.onopen = () => {
                    console.log('Connected to WebSocket');
                    // Reset reconnection attempts
                    this.reconnectAttempts = 0;
                };

                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);

                    if (message.type === 'chat_message') {
                        if (message.content) {
                            // Handle streaming chunks
                            const chatMessage = message.content;

                            // If this is the first chunk of a response, create a new message
                            if (this.isTyping) {
                                this.isTyping = false;
                                this.messages.push({
                                    role: 'assistant',
                                    content: chatMessage.content || '',
                                    timestamp: new Date(chatMessage.timestamp)
                                });
                            } else if (chatMessage.content) {
                                // Append to the last message for streaming updates
                                const lastMessage = this.messages[this.messages.length - 1];
                                if (lastMessage && lastMessage.role === 'assistant') {
                                    lastMessage.content += chatMessage.content;
                                }
                            }

                            this.scrollToBottom();
                        } else if (message.metadata && message.metadata.complete) {
                            // Message is complete, can update UI if needed
                            console.log('Message complete, processing time:', message.metadata.processingTime);
                            this.isLoading = false;
                        }
                    } else if (message.type === 'typing') {
                        this.isTyping = true;
                        this.scrollToBottom();
                    } else if (message.type === 'pong') {
                        // Received pong from server
                    }
                };

                this.ws.onclose = (event) => {
                    console.log(`WebSocket closed: ${event.code} ${event.reason}`);
                    // Implement exponential backoff for reconnection
                    const delay = Math.min(1000 * Math.pow(1.5, this.reconnectAttempts), 10000);
                    this.reconnectAttempts++;
                    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
                    setTimeout(() => this.connectWebSocket(), delay);
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };

                // Handle ping/pong
                setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({ type: "ping" }));
                    }
                }, 30000);
            },
            sendMessage() {
                if (!this.newMessage.trim() || this.isLoading) return;

                const message = {
                    role: 'user',
                    content: this.newMessage.trim(),
                    timestamp: new Date()
                };

                this.messages.push(message);
                this.scrollToBottom();

                // Clear input field
                const messageText = this.newMessage.trim();
                this.newMessage = '';

                // If this is a new chat, we need to create it first
                let apiRequest = Promise.resolve(this.chatId);

                if (this.chatId === 'new') {
                    // Create a new chat
                    apiRequest = fetch('/api/v1/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            title: messageText.substring(0, 30) + (messageText.length > 30 ? '...' : '')
                        })
                    })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Failed to create chat');
                            }
                            return response.json();
                        })
                        .then(data => {
                            // Update URL with new chat ID without page reload
                            const url = new URL(window.location);
                            url.searchParams.set('id', data.id);
                            window.history.pushState({}, '', url);

                            // Update chatId
                            this.chatId = data.id;
                            return data.id;
                        });
                }

                // Send message via WebSocket after chat is created (if needed)
                apiRequest
                    .then(chatId => {
                        this.isLoading = true;

                        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.ws.send(JSON.stringify({
                                type: 'chat_message',
                                content: {  // FIXED: Removed JSON.stringify
                                    chatId: chatId,
                                    content: messageText,
                                    role: 'user',
                                    timestamp: message.timestamp
                                }
                            }));

                            // Show typing indicator
                            setTimeout(() => {
                                this.isTyping = true;
                                this.scrollToBottom();
                            }, 300);
                        } else {
                            throw new Error('WebSocket not connected');
                        }
                    })
                    .catch(error => {
                        console.error('Error sending message:', error);
                        // Add error message to chat
                        this.messages.push({
                            role: 'system',
                            content: 'Failed to send message. Please try again.',
                            timestamp: new Date()
                        });
                        this.isLoading = false;
                        this.scrollToBottom();
                    });
            },

            scrollToBottom() {
                setTimeout(() => {
                    const scrollAnchor = document.getElementById('scroll-anchor');
                    if (scrollAnchor) {
                        scrollAnchor.scrollIntoView({ behavior: 'smooth' });
                    }
                }, 100);
            },

            formatTime(timestamp) {
                if (!timestamp) return '';
                const date = new Date(timestamp);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            },

            formatMessage(content) {
                // Simple markdown-like formatting
                if (!content) return '';
                // Format code blocks
                content = content.replace(/```(\w+)?\n([\s\S]*?)\n```/g, '<div class="code-block"><pre><code>$2</code></pre></div>');
                // Format inline code
                content = content.replace(/`([^`]+)`/g, '<code class="bg-gray-700 dark:bg-gray-700 px-1 rounded text-gray-200">$1</code>');
                // Convert line breaks to <br>
                content = content.replace(/\n/g, '<br>');
                return content;
            },

            autoGrow(element) {
                element.style.height = 'auto';
                element.style.height = (element.scrollHeight) + 'px';
                // Limit to 5 rows
                const lineHeight = parseInt(getComputedStyle(element).lineHeight);
                const maxHeight = lineHeight * 5;
                if (element.scrollHeight > maxHeight) {
                    element.style.height = maxHeight + 'px';
                    element.style.overflowY = 'auto';
                } else {
                    element.style.overflowY = 'hidden';
                }
            }
        }
    }
</script>
{{ end }}