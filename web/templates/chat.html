<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7x42 Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/alpinejs@3.13.3/dist/cdn.min.js" defer></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            400: '#38bdf8',
                            500: '#0ea5e9',
                            600: '#0284c7',
                        },
                        dark: {
                            800: '#0f172a',
                            900: '#020617',
                        }
                    }
                }
            }
        };
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .scrollbar-thin {
                scrollbar-width: thin;
            }
            .scrollbar-none {
                scrollbar-width: none;
            }
            .scrollbar-none::-webkit-scrollbar {
                display: none;
            }
            .code-block {
                background-color: rgba(30, 41, 59, 0.8);
                border-radius: 0.375rem;
                padding: 1rem;
                overflow-x: auto;
                margin: 0.75rem 0;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                font-size: 0.875rem;
                line-height: 1.5;
                color: #e2e8f0;
            }
            .light .code-block {
                background-color: rgba(226, 232, 240, 0.8);
                color: #1e293b;
            }
        }
    </style>
</head>
<body class="bg-white dark:bg-dark-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col transition-colors duration-200">
<div x-data="chatApp()" class="flex flex-col h-screen max-h-screen">
    <!-- Header -->
    <header class="bg-gray-100 dark:bg-dark-800 border-b border-gray-200 dark:border-gray-800 py-3 px-4 transition-colors duration-200">
        <div class="flex justify-between items-center">
            <h1 class="text-xl font-bold text-primary-600 dark:text-primary-400">7x42 Chat</h1>
            <button @click="toggleDarkMode()" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors">
                <!-- Sun icon for dark mode (show in dark mode) -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden dark:block text-yellow-300" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd" />
                </svg>
                <!-- Moon icon for light mode (show in light mode) -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 block dark:hidden text-gray-700" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" />
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Chat Area -->
    <div class="flex-1 overflow-hidden flex flex-col transition-colors duration-200">
        <!-- Chat history -->
        <div class="flex-1 overflow-y-auto px-2 py-6 space-y-6 scrollbar-thin bg-gray-50 dark:bg-dark-900 transition-colors duration-200" id="chat-messages">
            <template x-for="(message, index) in messages" :key="index">
                <div :class="message.role === 'user' ? 'flex justify-end' : 'flex justify-start'" class="mx-1 sm:mx-2">
                    <div :class="message.role === 'user' ?
                            'bg-primary-500 text-white rounded-2xl rounded-tr-none py-3 px-4 max-w-[95%]' :
                            'bg-gray-200 dark:bg-[#1e293b] text-gray-800 dark:text-gray-100 rounded-2xl rounded-tl-none py-3 px-4 max-w-[95%] transition-colors duration-200'">
                        <div x-html="formatMessage(message.content)" class="message-content"></div>
                        <div class="text-xs mt-1 opacity-70 text-right" x-text="formatTime(message.timestamp)"></div>
                    </div>
                </div>
            </template>

            <!-- Typing indicator (only visible when isTyping is true) -->
            <div x-show="isTyping" class="flex justify-start mx-1 sm:mx-2">
                <div class="bg-gray-200 dark:bg-[#1e293b] text-gray-800 dark:text-gray-100 rounded-2xl rounded-tl-none py-3 px-4 transition-colors duration-200">
                    <div class="flex space-x-1">
                        <div class="w-2 h-2 rounded-full bg-gray-500 dark:bg-gray-400 animate-bounce"></div>
                        <div class="w-2 h-2 rounded-full bg-gray-500 dark:bg-gray-400 animate-bounce" style="animation-delay: 0.2s"></div>
                        <div class="w-2 h-2 rounded-full bg-gray-500 dark:bg-gray-400 animate-bounce" style="animation-delay: 0.4s"></div>
                    </div>
                </div>
            </div>

            <!-- Scroll anchor -->
            <div id="scroll-anchor"></div>
        </div>

        <!-- Message input form -->
        <div class="border-t border-gray-200 dark:border-gray-800 bg-white dark:bg-dark-800 p-4 transition-colors duration-200">
            <form @submit.prevent="sendMessage" class="flex space-x-2">
                <div class="flex-1 relative">
                        <textarea
                                x-model="newMessage"
                                @keydown.enter.prevent="$event.shiftKey || sendMessage()"
                                class="w-full border border-gray-300 dark:border-gray-700 rounded-lg py-3 px-4 pr-12 focus:outline-none focus:ring-2 focus:ring-primary-500 dark:focus:ring-primary-400 bg-white dark:bg-[#1e293b] text-gray-800 dark:text-gray-100 resize-none transition-colors duration-200"
                                placeholder="Type a message..."
                                rows="1"
                                @input="autoGrow($event.target)"
                        ></textarea>
                    <div x-show="isLoading" class="absolute right-3 top-3.5">
                        <svg class="animate-spin h-5 w-5 text-primary-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                </div>
                <button
                        type="submit"
                        class="bg-primary-500 hover:bg-primary-600 text-white rounded-lg p-3 disabled:opacity-50 disabled:cursor-not-allowed"
                        :disabled="!newMessage.trim() || isLoading"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
                    </svg>
                </button>
            </form>
        </div>
    </div>
</div>

<script>
    function chatApp() {
        return {
            messages: [],
            newMessage: '',
            isLoading: false,
            isTyping: false,
            userId: 'user-' + Date.now(),
            ws: null,

            init() {
                this.loadMessages();
                this.connectWebSocket();

                // Check system preference for dark mode on first load
                if (localStorage.theme === 'dark' ||
                    (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            },

            toggleDarkMode() {
                if (document.documentElement.classList.contains('dark')) {
                    document.documentElement.classList.remove('dark');
                    localStorage.theme = 'light';
                } else {
                    document.documentElement.classList.add('dark');
                    localStorage.theme = 'dark';
                }
            },

            connectWebSocket() {
                this.ws = new WebSocket(`ws://${window.location.host}/ws/${this.userId}`);

                this.ws.onopen = () => {
                    console.log('Connected to WebSocket');
                };

                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    if (message.type === 'chat_message') {
                        const chatMessage = JSON.parse(message.content);
                        this.messages.push({
                            role: 'assistant',
                            content: chatMessage.content,
                            timestamp: new Date()
                        });
                        this.isTyping = false;
                        this.scrollToBottom();
                    } else if (message.type === 'typing') {
                        this.isTyping = true;
                        this.scrollToBottom();
                    }
                };

                this.ws.onclose = () => {
                    console.log('Disconnected from WebSocket');
                    // Implement reconnection logic
                    setTimeout(() => this.connectWebSocket(), 1000);
                };

                // Handle ping/pong
                setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({ type: "ping" }));
                    }
                }, 30000);
            },

            loadMessages() {
                // Sample messages for demo
                this.messages = [
                    {
                        role: 'user',
                        content: 'Hello! Can you help me with a Go Fiber question?',
                        timestamp: new Date(Date.now() - 1000 * 60 * 5)
                    },
                    {
                        role: 'assistant',
                        content: 'Of course! I\'d be happy to help with your Go Fiber question. What would you like to know?',
                        timestamp: new Date(Date.now() - 1000 * 60 * 4)
                    },
                    {
                        role: 'user',
                        content: 'How do I handle WebSocket connections in Fiber?',
                        timestamp: new Date(Date.now() - 1000 * 60 * 3)
                    },
                    {
                        role: 'assistant',
                        content: 'In Go Fiber, you can handle WebSocket connections using the official WebSocket middleware. Here\'s a basic example:\n\n```go\napp.Use("/ws", websocket.New(func(c *websocket.Conn) {\n    // Handle WebSocket connection here\n    for {\n        messageType, message, err := c.ReadMessage()\n        if err != nil {\n            break\n        }\n        \n        // Handle the message\n        // Send a response\n        c.WriteMessage(messageType, message)\n    }\n}))\n```\n\nThis sets up a WebSocket endpoint at "/ws" that echoes back any messages it receives.',
                        timestamp: new Date(Date.now() - 1000 * 60 * 2)
                    }
                ];
                setTimeout(() => this.scrollToBottom(), 100);
            },

            sendMessage() {
                if (!this.newMessage.trim() || this.isLoading) return;

                const message = {
                    role: 'user',
                    content: this.newMessage.trim(),
                    timestamp: new Date()
                };

                this.messages.push(message);
                this.scrollToBottom();

                // Send message via WebSocket
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.isLoading = true;
                    this.ws.send(JSON.stringify({
                        type: 'chat_message',
                        content: JSON.stringify({
                            content: message.content,
                            role: 'user',
                            timestamp: message.timestamp
                        })
                    }));

                    // Simulate typing indicator
                    setTimeout(() => {
                        this.isTyping = true;
                        this.scrollToBottom();
                    }, 500);

                    // Simulate response (remove this in production)
                    setTimeout(() => {
                        this.isLoading = false;
                        this.isTyping = false;
                        this.messages.push({
                            role: 'assistant',
                            content: 'This is a simulated response. In a real application, this would come from the server via WebSocket.',
                            timestamp: new Date()
                        });
                        this.scrollToBottom();
                    }, 2000);
                }

                this.newMessage = '';
            },

            scrollToBottom() {
                setTimeout(() => {
                    const scrollAnchor = document.getElementById('scroll-anchor');
                    if (scrollAnchor) {
                        scrollAnchor.scrollIntoView({ behavior: 'smooth' });
                    }
                }, 100);
            },

            formatTime(timestamp) {
                if (!timestamp) return '';
                const date = new Date(timestamp);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            },

            formatMessage(content) {
                // Simple markdown-like formatting
                if (!content) return '';

                // Format code blocks
                content = content.replace(/```(\w+)?\n([\s\S]*?)\n```/g, '<div class="code-block"><pre><code>$2</code></pre></div>');

                // Format inline code
                content = content.replace(/`([^`]+)`/g, '<code class="bg-gray-700 dark:bg-gray-700 px-1 rounded text-gray-200">$1</code>');

                // Convert line breaks to <br>
                content = content.replace(/\n/g, '<br>');

                return content;
            },

            autoGrow(element) {
                element.style.height = 'auto';
                element.style.height = (element.scrollHeight) + 'px';

                // Limit to 5 rows
                const lineHeight = parseInt(getComputedStyle(element).lineHeight);
                const maxHeight = lineHeight * 5;
                if (element.scrollHeight > maxHeight) {
                    element.style.height = maxHeight + 'px';
                    element.style.overflowY = 'auto';
                } else {
                    element.style.overflowY = 'hidden';
                }
            }
        }
    }
</script>
</body>
</html>